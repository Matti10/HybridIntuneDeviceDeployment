
# Documentation

<#
.SYNOPSIS
    This function handles device build errors, writing out a detailed account of the error(s) to a specified log file.
.DESCRIPTION
    By leveraging PowerShell's robust error handling capabilities, this function captures a wealth of information about any errors that occur during a device build process.
    It formats and logs this information in an easy-to-read, human-friendly manner to assist debuggers in identifying and resolving the issues that led to the build failure.
.PARAMETER BuildInfo
    A mandatory parameter that accepts pipeline input. Used to store build information, including the current state of the build.
.PARAMETER errorObject
    An optional parameter intended to catch the error object generated by a terminating error.
.PARAMETER stack
    An optional parameter designed to capture the PowerShell call stack. By default, it fetches the current call stack using the Get-PSCallStack cmdlet.
.PARAMETER additionalInfo
    An optional parameter that can be used to add any additional information that might be relevant to understanding the cause of the error.
.PARAMETER logPath
    The path to the log file where the error should be written. By default, it uses the buildPCLogPath from the current device deployment configuration.
.PARAMETER content
    Optional string parameter that holds the formatted contents of the error message. By default, it uses the messageTemplate from the current device deployment configuration.
.PARAMETER errorState
    An optional parameter that sets the state of the build to 'failed' by default.
.PARAMETER message
    An optional string parameter for adding a custom error message.
.PARAMETER dateFormat
    An optional string parameter that specifies the format in which dates should be displayed. Defaults to the current device deployment configuration's DefaultDateFormat setting.
.EXAMPLE
    Write-DeviceBuildError -BuildInfo $BuildInfo -errorObject $error -additionalInfo "Failed to load module"
    In the example above, the function captures and logs a wealth of insight about the error, such as the call stack, the specific error, where in the sequence of events the error occurred, and any additional information supplied.
.INPUTS
    System.Object, ErrorObject, CallStack, AdditionalInformation, LogPath, Content, ErrorState, Message, DateFormat
.OUTPUTS
    None. This cmdlet does not return any output, it writes information to a logging path.
.NOTES
    This function supports the should process property, allowing it to leverage the WhatIf and Confirm parameters available in advanced functions.
#>
function Write-DeviceBuildError {
	[CmdletBinding(SupportsShouldProcess = $true)]
	param (
		[Parameter(Mandatory, ValueFromPipeline)]
		[System.Object]$BuildInfo,

		[Parameter()]
		$errorObject = $null,

		[Parameter()]
		$stack = (Get-PSCallStack),

		[Parameter()]
		$additionalInfo = $null,

		[Parameter()]
		$logPath = $DeviceDeploymentDefaultConfig.Logging.buildPCLogPath,

		[Parameter()]
		[string]$content = $DeviceDeploymentDefaultConfig.TicketInteraction.messageTemplate,

		[Parameter()]
		$errorState = $DeviceDeploymentDefaultConfig.TicketInteraction.BuildStates.failedState,

		[Parameter()]
		[string]$message,

		[Parameter()]
		[string]$dateFormat = $DeviceDeploymentDefaultConfig.Generic.DefaultDateFormat
	)

	begin {
		$errorList = @()
	}
	process {
		try {
			# Updating the build state to indicate error condition
			$BuildInfo.buildState = $errorState.message

			# Initial format for the error message
			$content = "An Error has occured during the build process"

			# Attempt to retrieve actual error message depending on where it's stored
			try {
				$errorMsg = $errorObject.exception.Message
			} catch {
				try {
					$errorMsg = $errorObject.exception.ErrorRecord
				}
				catch {
					$errorMsg = "Unknown"
				}
			}

			# Constructing the error message content
			if ($null -ne $errorObject) {
				$content += ":<br><b>Solution & Details:</b> $message<br><b>Error Location/Function:</b> $($stack[1].Command)<br><b>Error Message:</b> $($errorMsg)<br>"
			}
			else {
                # Add information about function execution location and log file path
				$content += " when running the $($stack[1].Command) function. More details can be found in the log file, located @ $logPath path<br>(remember, to access file explorer in OOBE, press shift+F10, then type 'explorer' into the cmd window)"
			}

			# Adding additional informational content if it's available
			if ($null -ne $additionalInfo) {
				$content += "<br><b>Additional Information: </b>$additionalInfo"
			}

			# Formatting final content
			$content = "<table><tr><th style=`"background-color:$($errorState.color)`">Error Information</th></tr><tr><td>$content</td></tr></table>"

            # Calling the Write-DeviceBuildTicket function to log a ticket with the formed error content
			Send-eMailMessage -Body $content -FromEmail "BuildProcessAgent@tricare.com.au" -ToEmail $BuildInfo.userEmail -Subject "Error in build of $($BuildInfo.AssetID)" -bcc "matt.winsen@tricare.com.au"
			# Outputting the captured stack trace for additional debugging information
			Write-Host "StackTrace:"
			foreach ($call in $stack) {
				Write-Host "$($call)"
			}
		}
		catch {
			$errorList += $_
			Write-Error $_
		}
	}
	end {
		# Writing out any errors occurred in the current function
		if ($errorList.count -ne 0) {
			Write-Error "Error(s) in $($MyInvocation.MyCommand.Name):`n$($errorList | ForEach-Object {"$_`n"})`n $(Get-PSCallStack)" -ErrorAction Stop
		}
	}	
}